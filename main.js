/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BookStackSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  baseUrl: "",
  tokenIdSecret: "",
  tokenSecretSecret: "",
  syncFolder: "BookStack",
  selectedBooks: [],
  autoSync: false,
  syncInterval: 60,
  syncMode: "bidirectional"
};
var BookStackSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    this.isSyncing = false;
    this.bookFolderCache = /* @__PURE__ */ new Map();
    this.chapterFolderCache = /* @__PURE__ */ new Map();
    this.pageFolderCache = /* @__PURE__ */ new Map();
    // Constants
    this.SYNC_TIME_BUFFER_MS = 1e3;
    this.README_FILENAME = "README.md";
    this.MARKDOWN_EXTENSION = "md";
  }
  get isMobile() {
    var _a;
    return (_a = this.app.isMobile) != null ? _a : false;
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("folder-sync", "BookStack Sync", async () => {
      await this.syncBooks();
    });
    this.addCommand({
      id: "sync-bookstack",
      name: "Sync BookStack Books",
      callback: async () => {
        await this.syncBooks();
      }
    });
    this.addCommand({
      id: "pull-from-bookstack",
      name: "Pull from BookStack (Download only)",
      callback: async () => {
        if (this.isSyncing) {
          new import_obsidian.Notice("Sync already in progress...");
          return;
        }
        this.isSyncing = true;
        this.bookFolderCache.clear();
        this.chapterFolderCache.clear();
        this.pageFolderCache.clear();
        try {
          await this.pullFromBookStack();
        } finally {
          this.isSyncing = false;
        }
      }
    });
    this.addCommand({
      id: "push-to-bookstack",
      name: "Push to BookStack (Upload only)",
      callback: async () => {
        if (this.isSyncing) {
          new import_obsidian.Notice("Sync already in progress...");
          return;
        }
        this.isSyncing = true;
        try {
          await this.pushToBookStack();
        } finally {
          this.isSyncing = false;
        }
      }
    });
    this.addCommand({
      id: "select-books",
      name: "Select Books to Sync",
      callback: () => {
        new BookSelectionModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "test-connection",
      name: "Test BookStack Connection",
      callback: async () => {
        await this.testConnection();
      }
    });
    this.addSettingTab(new BookStackSettingTab(this.app, this));
    if (this.settings.autoSync) {
      this.startAutoSync();
    }
  }
  onunload() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  startAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
    }
    this.syncIntervalId = window.setInterval(
      () => this.syncBooks(),
      this.settings.syncInterval * 60 * 1e3
    );
  }
  stopAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
  }
  async getCredentials() {
    const tokenId = await this.app.secretStorage.getSecret(this.settings.tokenIdSecret);
    const tokenSecret = await this.app.secretStorage.getSecret(this.settings.tokenSecretSecret);
    return { tokenId, tokenSecret };
  }
  async makeRequest(endpoint, method = "GET", body) {
    const { tokenId, tokenSecret } = await this.getCredentials();
    if (!tokenId || !tokenSecret) {
      throw new Error("API credentials not configured. Please set up your BookStack API tokens in settings.");
    }
    const url = `${this.settings.baseUrl}/api/${endpoint}`;
    const headers = {
      "Authorization": `Token ${tokenId}:${tokenSecret}`,
      "Accept": "application/json"
    };
    if (body !== void 0) {
      headers["Content-Type"] = "application/json";
    }
    try {
      console.log(`[BookStack] ${method} ${url} via requestUrl`);
      const res = await (0, import_obsidian.requestUrl)({
        url,
        method,
        headers,
        body: body !== void 0 ? JSON.stringify(body) : void 0,
        throw: false
      });
      console.log(`[BookStack] Response status: ${res.status}`);
      if (res.status < 200 || res.status >= 300) {
        throw new Error(`HTTP ${res.status}: ${res.text}`);
      }
      return res.json;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      const errorName = error instanceof Error ? error.name : "Unknown";
      const detailedError = `API Error [${errorName}]: ${errorMsg}`;
      console.error(`[BookStack] ${detailedError}`, {
        url,
        method,
        endpoint,
        error,
        platform: this.isMobile ? "mobile" : "desktop"
      });
      new import_obsidian.Notice(`${detailedError}

Check console for details`);
      throw error;
    }
  }
  async listBooks() {
    const response = await this.makeRequest("books");
    return response.data;
  }
  async getBook(bookId) {
    return await this.makeRequest(`books/${bookId}`);
  }
  async getChapter(chapterId) {
    return await this.makeRequest(`chapters/${chapterId}`);
  }
  async getPage(pageId) {
    return await this.makeRequest(`pages/${pageId}`);
  }
  async createPage(bookId, name, markdown, chapterId) {
    const createData = {
      book_id: bookId,
      name,
      markdown
    };
    if (chapterId) {
      createData.chapter_id = chapterId;
    }
    return await this.makeRequest("pages", "POST", createData);
  }
  async createChapter(bookId, name, description) {
    const createData = {
      book_id: bookId,
      name,
      description: description || ""
    };
    return await this.makeRequest("chapters", "POST", createData);
  }
  async updatePage(pageId, content, name) {
    const updateData = {
      markdown: content
    };
    if (name) {
      updateData.name = name;
    }
    return await this.makeRequest(`pages/${pageId}`, "PUT", updateData);
  }
  async exportPageMarkdown(pageId) {
    const { tokenId, tokenSecret } = await this.getCredentials();
    if (!tokenId || !tokenSecret) {
      throw new Error("API credentials not configured");
    }
    const url = `${this.settings.baseUrl}/api/pages/${pageId}/export/markdown`;
    try {
      console.log(`[BookStack] Exporting markdown for page ${pageId}`);
      const res = await (0, import_obsidian.requestUrl)({
        url,
        headers: {
          "Authorization": `Token ${tokenId}:${tokenSecret}`,
          "Accept": "text/markdown, text/plain, */*"
        },
        throw: false
      });
      console.log(`[BookStack] Export response status: ${res.status}`);
      if (res.status !== 200) {
        throw new Error(`Failed to export page ${pageId}: HTTP ${res.status}`);
      }
      return res.text;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`[BookStack] Export markdown error: ${errorMsg}`, error);
      throw error;
    }
  }
  extractFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
    if (!match) {
      return { frontmatter: {}, body: content };
    }
    const yamlText = match[1];
    const body = match[2];
    const frontmatter = {};
    yamlText.split("\n").forEach((line) => {
      const colonIndex = line.indexOf(":");
      if (colonIndex === -1)
        return;
      const key = line.substring(0, colonIndex).trim();
      let value = line.substring(colonIndex + 1).trim();
      if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
        value = value.slice(1, -1);
      }
      if (key === "bookstack_id" || key === "book_id" || key === "chapter_id") {
        const num = parseInt(value);
        if (!isNaN(num)) {
          frontmatter[key] = num;
        } else if (value === "null" || value === "") {
          frontmatter[key] = null;
        }
      } else if (["title", "book_name", "chapter_name", "book_description", "chapter_description", "created", "updated", "last_synced"].includes(key)) {
        frontmatter[key] = value;
      }
    });
    return { frontmatter, body };
  }
  async extractFrontmatterOnly(file) {
    const content = await this.app.vault.read(file);
    if (!content.startsWith("---\n")) {
      return {};
    }
    const endIndex = content.indexOf("\n---\n", 4);
    if (endIndex === -1) {
      return {};
    }
    const frontmatterSection = content.substring(0, endIndex + 5);
    const { frontmatter } = this.extractFrontmatter(frontmatterSection + "\n");
    return frontmatter;
  }
  createFrontmatter(metadata) {
    var _a, _b, _c, _d, _e, _f;
    let fm = "---\n";
    fm += `title: ${(_a = metadata.title) != null ? _a : "Untitled"}
`;
    fm += `bookstack_id: ${(_b = metadata.bookstack_id) != null ? _b : ""}
`;
    fm += `book_id: ${(_c = metadata.book_id) != null ? _c : ""}
`;
    fm += `chapter_id: ${metadata.chapter_id !== void 0 ? metadata.chapter_id : ""}
`;
    if (metadata.book_name) {
      fm += `book_name: ${metadata.book_name}
`;
    }
    if (metadata.book_description) {
      fm += `book_description: "${metadata.book_description.replace(/"/g, '\\"')}"
`;
    }
    if (metadata.chapter_name) {
      fm += `chapter_name: ${metadata.chapter_name}
`;
    }
    if (metadata.chapter_description) {
      fm += `chapter_description: "${metadata.chapter_description.replace(/"/g, '\\"')}"
`;
    }
    fm += `created: ${(_d = metadata.created) != null ? _d : ""}
`;
    fm += `updated: ${(_e = metadata.updated) != null ? _e : ""}
`;
    fm += `last_synced: ${(_f = metadata.last_synced) != null ? _f : ""}
`;
    fm += "---\n\n";
    return fm;
  }
  htmlToMarkdown(html) {
    let md = html;
    md = md.replace(/<h1[^>]*>(.*?)<\/h1>/gi, "# $1\n");
    md = md.replace(/<h2[^>]*>(.*?)<\/h2>/gi, "## $1\n");
    md = md.replace(/<h3[^>]*>(.*?)<\/h3>/gi, "### $1\n");
    md = md.replace(/<h4[^>]*>(.*?)<\/h4>/gi, "#### $1\n");
    md = md.replace(/<h5[^>]*>(.*?)<\/h5>/gi, "##### $1\n");
    md = md.replace(/<h6[^>]*>(.*?)<\/h6>/gi, "###### $1\n");
    md = md.replace(/<strong[^>]*>(.*?)<\/strong>/gi, "**$1**");
    md = md.replace(/<b[^>]*>(.*?)<\/b>/gi, "**$1**");
    md = md.replace(/<em[^>]*>(.*?)<\/em>/gi, "*$1*");
    md = md.replace(/<i[^>]*>(.*?)<\/i>/gi, "*$1*");
    md = md.replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, "[$2]($1)");
    md = md.replace(/<img[^>]*src="([^"]*)"[^>]*alt="([^"]*)"[^>]*>/gi, "![$2]($1)");
    md = md.replace(/<img[^>]*src="([^"]*)"[^>]*>/gi, "![]($1)");
    md = md.replace(/<li[^>]*>(.*?)<\/li>/gi, "- $1\n");
    md = md.replace(/<ul[^>]*>/gi, "\n");
    md = md.replace(/<\/ul>/gi, "\n");
    md = md.replace(/<ol[^>]*>/gi, "\n");
    md = md.replace(/<\/ol>/gi, "\n");
    md = md.replace(/<p[^>]*>(.*?)<\/p>/gi, "$1\n\n");
    md = md.replace(/<pre[^>]*><code[^>]*>([\s\S]*?)<\/code><\/pre>/gis, "```\n$1\n```\n");
    md = md.replace(/<code[^>]*>(.*?)<\/code>/gi, "`$1`");
    md = md.replace(/<br\s*\/?\>/gi, "\n");
    md = md.replace(/<[^>]+>/g, "");
    md = md.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"');
    md = md.replace(/\n{3,}/g, "\n\n");
    return md.trim();
  }
  stripLeadingTitleFromBody(body, title) {
    if (!body || !title)
      return body;
    const lines = body.split("\n");
    if (lines.length === 0)
      return body;
    const firstLine = lines[0].trim();
    const normalizedTitle = title.trim();
    const h1Regex = /^#\s+(.+)$/;
    const match = firstLine.match(h1Regex);
    if (match) {
      const headingText = match[1].trim();
      if (headingText.toLowerCase() === normalizedTitle.toLowerCase()) {
        let startIndex = 1;
        while (startIndex < lines.length && lines[startIndex].trim() === "") {
          startIndex++;
        }
        return lines.slice(startIndex).join("\n");
      }
    }
    return body;
  }
  async syncBooks() {
    if (this.isSyncing) {
      new import_obsidian.Notice("Sync already in progress...");
      return;
    }
    if (!this.settings.baseUrl) {
      new import_obsidian.Notice("Please configure BookStack URL in settings");
      return;
    }
    const { tokenId, tokenSecret } = await this.getCredentials();
    if (!tokenId || !tokenSecret) {
      new import_obsidian.Notice("Please configure BookStack API credentials in settings");
      return;
    }
    if (this.settings.selectedBooks.length === 0) {
      new import_obsidian.Notice('No books selected for sync. Use "Select Books to Sync" command.');
      return;
    }
    this.isSyncing = true;
    this.bookFolderCache.clear();
    this.chapterFolderCache.clear();
    this.pageFolderCache.clear();
    try {
      switch (this.settings.syncMode) {
        case "pull-only":
          await this.pullFromBookStack();
          break;
        case "push-only":
          await this.pushToBookStack();
          break;
        case "bidirectional":
          await this.bidirectionalSync();
          break;
      }
    } catch (error) {
      new import_obsidian.Notice(`Sync failed: ${error.message}`);
      console.error("BookStack sync error:", error);
    } finally {
      this.isSyncing = false;
    }
  }
  async pullFromBookStack() {
    new import_obsidian.Notice("Pulling from BookStack...");
    this.bookFolderCache.clear();
    this.chapterFolderCache.clear();
    this.pageFolderCache.clear();
    const syncFolder = this.settings.syncFolder;
    await this.ensureFolderExists(syncFolder);
    let pullCount = 0;
    let skipCount = 0;
    let errorCount = 0;
    for (const bookId of this.settings.selectedBooks) {
      const result = await this.pullBook(bookId, syncFolder);
      pullCount += result.pulled;
      skipCount += result.skipped;
      errorCount += result.errors;
    }
    const summary = [];
    if (pullCount > 0)
      summary.push(`${pullCount} pulled`);
    if (skipCount > 0)
      summary.push(`${skipCount} skipped`);
    if (errorCount > 0)
      summary.push(`${errorCount} errors`);
    new import_obsidian.Notice(`Pull complete: ${summary.join(", ")}`);
  }
  async pushToBookStack() {
    new import_obsidian.Notice("Pushing to BookStack...");
    this.bookFolderCache.clear();
    this.chapterFolderCache.clear();
    this.pageFolderCache.clear();
    const syncFolder = this.settings.syncFolder;
    await this.ensureFolderExists(syncFolder);
    let pushCount = 0;
    let createCount = 0;
    let skipCount = 0;
    let errorCount = 0;
    for (const bookId of this.settings.selectedBooks) {
      const result = await this.pushBook(bookId, syncFolder);
      pushCount += result.pushed;
      createCount += result.created;
      skipCount += result.skipped;
      errorCount += result.errors;
    }
    const summary = [];
    if (createCount > 0)
      summary.push(`${createCount} created`);
    if (pushCount > 0)
      summary.push(`${pushCount} pushed`);
    if (skipCount > 0)
      summary.push(`${skipCount} skipped`);
    if (errorCount > 0)
      summary.push(`${errorCount} errors`);
    new import_obsidian.Notice(`Push complete: ${summary.join(", ")}`);
  }
  async bidirectionalSync() {
    new import_obsidian.Notice("Starting bidirectional sync...");
    this.bookFolderCache.clear();
    this.chapterFolderCache.clear();
    this.pageFolderCache.clear();
    const syncFolder = this.settings.syncFolder;
    await this.ensureFolderExists(syncFolder);
    let pullCount = 0;
    let pushCount = 0;
    let createCount = 0;
    let skipCount = 0;
    let errorCount = 0;
    for (const bookId of this.settings.selectedBooks) {
      const result = await this.syncBookBidirectional(bookId, syncFolder);
      pullCount += result.pulled;
      pushCount += result.pushed;
      createCount += result.created;
      skipCount += result.skipped;
      errorCount += result.errors;
    }
    const summary = [];
    if (createCount > 0)
      summary.push(`${createCount} created`);
    if (pullCount > 0)
      summary.push(`${pullCount} pulled`);
    if (pushCount > 0)
      summary.push(`${pushCount} pushed`);
    if (skipCount > 0)
      summary.push(`${skipCount} skipped`);
    if (errorCount > 0)
      summary.push(`${errorCount} errors`);
    new import_obsidian.Notice(`Sync complete: ${summary.join(", ")}`);
  }
  async pullBook(bookId, basePath) {
    let pulled = 0, skipped = 0, errors = 0;
    try {
      const book = await this.getBook(bookId);
      const bookPath = await this.findOrCreateFolderWithRename(
        bookId,
        book.name,
        basePath,
        (id, parent) => this.findBookFolderByBookId(id, parent),
        "book"
      );
      for (const content of book.contents) {
        if (content.type === "chapter") {
          const result = await this.pullChapter(content.id, bookPath, book);
          pulled += result.pulled;
          skipped += result.skipped;
          errors += result.errors;
        } else if (content.type === "page") {
          const result = await this.pullPageSync(content.id, bookPath, book);
          switch (result) {
            case "pulled":
              pulled++;
              break;
            case "skipped":
              skipped++;
              break;
            case "error":
              errors++;
              break;
          }
        }
      }
    } catch (error) {
      this.handleSyncError(`Failed to pull book ${bookId}`, error);
      errors++;
    }
    return { pulled, skipped, errors };
  }
  async pushBook(bookId, basePath) {
    let pushed = 0, created = 0, skipped = 0, errors = 0;
    try {
      const book = await this.getBook(bookId);
      const bookPath = await this.findOrCreateFolderWithRename(
        bookId,
        book.name,
        basePath,
        (id, parent) => this.findBookFolderByBookId(id, parent),
        "book"
      );
      for (const content of book.contents) {
        if (content.type === "chapter") {
          const result = await this.pushChapter(content.id, bookPath, book);
          pushed += result.pushed;
          skipped += result.skipped;
          errors += result.errors;
        } else if (content.type === "page") {
          const result = await this.pushPageSync(content.id, bookPath, book);
          switch (result) {
            case "pushed":
              pushed++;
              break;
            case "skipped":
              skipped++;
              break;
            case "error":
              errors++;
              break;
          }
        }
      }
      const localResult = await this.syncLocalPages(bookPath, book);
      created += localResult.created;
      errors += localResult.errors;
    } catch (error) {
      this.handleSyncError(`Failed to push book ${bookId}`, error);
      errors++;
    }
    return { pushed, created, skipped, errors };
  }
  async syncBookBidirectional(bookId, basePath) {
    let pulled = 0, pushed = 0, created = 0, skipped = 0, errors = 0;
    try {
      const book = await this.getBook(bookId);
      const bookPath = await this.findOrCreateFolderWithRename(
        bookId,
        book.name,
        basePath,
        (id, parent) => this.findBookFolderByBookId(id, parent),
        "book"
      );
      for (const content of book.contents) {
        if (content.type === "chapter") {
          const result = await this.syncChapterBidirectional(content.id, bookPath, book);
          pulled += result.pulled;
          pushed += result.pushed;
          created += result.created;
          skipped += result.skipped;
          errors += result.errors;
        } else if (content.type === "page") {
          const result = await this.syncPageBidirectional(content.id, bookPath, book);
          switch (result) {
            case "pulled":
              pulled++;
              break;
            case "pushed":
              pushed++;
              break;
            case "created":
              created++;
              break;
            case "skipped":
              skipped++;
              break;
            case "error":
              errors++;
              break;
          }
        }
      }
      const localResult = await this.syncLocalPages(bookPath, book);
      created += localResult.created;
      errors += localResult.errors;
    } catch (error) {
      this.handleSyncError(`Failed to sync book ${bookId}`, error);
      errors++;
    }
    return { pulled, pushed, created, skipped, errors };
  }
  async pullChapter(chapterId, bookPath, book) {
    let pulled = 0, skipped = 0, errors = 0;
    try {
      const chapter = await this.getChapter(chapterId);
      const chapterPath = await this.findOrCreateFolderWithRename(
        chapterId,
        chapter.name,
        bookPath,
        (id, parent) => this.findChapterFolderByChapterId(id, parent),
        "chapter"
      );
      if (chapter.pages) {
        for (const page of chapter.pages) {
          const result = await this.pullPageSync(page.id, chapterPath, book, chapter);
          switch (result) {
            case "pulled":
              pulled++;
              break;
            case "skipped":
              skipped++;
              break;
            case "error":
              errors++;
              break;
          }
        }
      }
    } catch (error) {
      this.handleSyncError(`Failed to pull chapter ${chapterId}`, error);
      errors++;
    }
    return { pulled, skipped, errors };
  }
  async pushChapter(chapterId, bookPath, book) {
    let pushed = 0, skipped = 0, errors = 0;
    try {
      const chapter = await this.getChapter(chapterId);
      const chapterPath = await this.findOrCreateFolderWithRename(
        chapterId,
        chapter.name,
        bookPath,
        (id, parent) => this.findChapterFolderByChapterId(id, parent),
        "chapter"
      );
      if (chapter.pages) {
        for (const page of chapter.pages) {
          const result = await this.pushPageSync(page.id, chapterPath, book, chapter);
          switch (result) {
            case "pushed":
              pushed++;
              break;
            case "skipped":
              skipped++;
              break;
            case "error":
              errors++;
              break;
          }
        }
      }
      const localResult = await this.syncLocalPages(chapterPath, book, chapter);
      errors += localResult.errors;
    } catch (error) {
      this.handleSyncError(`Failed to push chapter ${chapterId}`, error);
      errors++;
    }
    return { pushed, skipped, errors };
  }
  async syncChapterBidirectional(chapterId, bookPath, book) {
    let pulled = 0, pushed = 0, created = 0, skipped = 0, errors = 0;
    try {
      const chapter = await this.getChapter(chapterId);
      const chapterPath = await this.findOrCreateFolderWithRename(
        chapterId,
        chapter.name,
        bookPath,
        (id, parent) => this.findChapterFolderByChapterId(id, parent),
        "chapter"
      );
      if (chapter.pages) {
        for (const page of chapter.pages) {
          const result = await this.syncPageBidirectional(page.id, chapterPath, book, chapter);
          switch (result) {
            case "pulled":
              pulled++;
              break;
            case "pushed":
              pushed++;
              break;
            case "created":
              created++;
              break;
            case "skipped":
              skipped++;
              break;
            case "error":
              errors++;
              break;
          }
        }
      }
      const localResult = await this.syncLocalPages(chapterPath, book, chapter);
      created += localResult.created;
      errors += localResult.errors;
    } catch (error) {
      this.handleSyncError(`Failed to sync chapter ${chapterId}`, error);
      errors++;
    }
    return { pulled, pushed, created, skipped, errors };
  }
  async syncLocalPages(folderPath, book, chapter) {
    var _a;
    let created = 0;
    let errors = 0;
    try {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof import_obsidian.TFolder)) {
        return { created, errors };
      }
      for (const item of folder.children) {
        if (item instanceof import_obsidian.TFolder) {
          if (!chapter) {
            await this.handlePotentialNewChapter(item, book);
          }
        }
      }
      for (const file of folder.children) {
        if (!(file instanceof import_obsidian.TFile) || this.shouldSkipFile(file))
          continue;
        const content = await this.app.vault.read(file);
        const { frontmatter, body } = this.extractFrontmatter(content);
        if (!frontmatter.bookstack_id) {
          try {
            console.log(`Creating new page in BookStack: ${file.basename}`);
            const newPage = await this.createPage(
              book.id,
              file.basename,
              body,
              chapter == null ? void 0 : chapter.id
            );
            frontmatter.bookstack_id = newPage.id;
            frontmatter.book_id = book.id;
            frontmatter.chapter_id = (_a = chapter == null ? void 0 : chapter.id) != null ? _a : null;
            frontmatter.book_name = book.name;
            frontmatter.book_description = book.description;
            if (chapter) {
              frontmatter.chapter_name = chapter.name;
              frontmatter.chapter_description = chapter.description;
            }
            frontmatter.created = newPage.created_at;
            frontmatter.updated = newPage.updated_at;
            frontmatter.last_synced = new Date().toISOString();
            frontmatter.title = file.basename;
            const updatedContent = this.createFrontmatter(frontmatter) + body;
            await this.app.vault.modify(file, updatedContent);
            new import_obsidian.Notice(`Created page in BookStack: ${file.basename}`);
            created++;
          } catch (error) {
            this.handleSyncError(`Failed to create page ${file.basename}`, error);
            new import_obsidian.Notice(`Failed to create page: ${file.basename}`);
            errors++;
          }
        }
      }
    } catch (error) {
      this.handleSyncError(`Failed to sync local pages in ${folderPath}`, error);
      errors++;
    }
    return { created, errors };
  }
  async handlePotentialNewChapter(folder, book) {
    const folderName = folder.name;
    let existingChapterId = null;
    for (const file of folder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        const content = await this.app.vault.read(file);
        const { frontmatter } = this.extractFrontmatter(content);
        if (frontmatter.chapter_id) {
          existingChapterId = frontmatter.chapter_id;
          break;
        }
      }
    }
    if (!existingChapterId) {
      try {
        console.log(`Creating new chapter in BookStack: ${folderName}`);
        const newChapter = await this.createChapter(book.id, folderName);
        new import_obsidian.Notice(`Created chapter in BookStack: ${folderName}`);
        const chapterResult = await this.syncLocalPages(folder.path, book, newChapter);
        console.log(`Synced ${chapterResult.created} pages in new chapter ${folderName}`);
      } catch (error) {
        this.handleSyncError(`Failed to create chapter ${folderName}`, error);
        new import_obsidian.Notice(`Failed to create chapter: ${folderName}`);
      }
    } else {
      console.log(`[BookStack] Existing chapter detected: ${folderName} (ID: ${existingChapterId})`);
    }
  }
  async pullPageSync(pageId, parentPath, book, chapter) {
    try {
      const page = await this.getPage(pageId);
      let existingFile = await this.findFileByBookStackId(pageId, parentPath);
      if (existingFile) {
        existingFile = await this.renameFileIfNeeded(existingFile, page.name, parentPath);
      }
      const expectedFilePath = `${parentPath}/${this.sanitizeFileName(page.name)}.md`;
      const remoteUpdated = new Date(page.updated_at);
      if (existingFile instanceof import_obsidian.TFile) {
        const localContent = await this.app.vault.read(existingFile);
        const { frontmatter } = this.extractFrontmatter(localContent);
        const lastSynced = frontmatter.last_synced ? new Date(frontmatter.last_synced) : null;
        if (lastSynced && remoteUpdated <= lastSynced) {
          return "skipped";
        }
      }
      await this.pullPage(page, expectedFilePath, book, chapter);
      return "pulled";
    } catch (error) {
      console.error(`Failed to pull page ${pageId}:`, error);
      return "error";
    }
  }
  async pushPageSync(pageId, parentPath, book, chapter) {
    try {
      const page = await this.getPage(pageId);
      let existingFile = await this.findFileByBookStackId(pageId, parentPath);
      if (!existingFile) {
        return "skipped";
      }
      existingFile = await this.renameFileIfNeeded(existingFile, page.name, parentPath);
      const localContent = await this.app.vault.read(existingFile);
      const { frontmatter, body } = this.extractFrontmatter(localContent);
      const lastSynced = frontmatter.last_synced ? new Date(frontmatter.last_synced) : null;
      const localModified = new Date(existingFile.stat.mtime);
      const hasLocalChanges = !!lastSynced && localModified > new Date(lastSynced.getTime() + this.SYNC_TIME_BUFFER_MS);
      if (hasLocalChanges) {
        const cleanedBody = this.stripLeadingTitleFromBody(body, page.name);
        await this.pushPage(page.id, cleanedBody, page.name);
        await this.updateLocalSyncTime(existingFile, frontmatter, body);
        return "pushed";
      }
      return "skipped";
    } catch (error) {
      console.error(`Failed to push page ${pageId}:`, error);
      return "error";
    }
  }
  async syncPageBidirectional(pageId, parentPath, book, chapter) {
    try {
      const page = await this.getPage(pageId);
      let existingFile = await this.findFileByBookStackId(pageId, parentPath);
      if (existingFile) {
        existingFile = await this.renameFileIfNeeded(existingFile, page.name, parentPath);
      }
      const expectedFilePath = `${parentPath}/${this.sanitizeFileName(page.name)}.md`;
      const remoteUpdated = new Date(page.updated_at);
      if (existingFile instanceof import_obsidian.TFile) {
        const localContent = await this.app.vault.read(existingFile);
        const { frontmatter, body } = this.extractFrontmatter(localContent);
        const lastSynced = frontmatter.last_synced ? new Date(frontmatter.last_synced) : null;
        const localModified = new Date(existingFile.stat.mtime);
        const hasLocalChanges = !!lastSynced && localModified > new Date(lastSynced.getTime() + this.SYNC_TIME_BUFFER_MS);
        if (hasLocalChanges && lastSynced) {
          if (remoteUpdated > lastSynced) {
            const remoteContent = await this.getRemotePageContent(page);
            return new Promise((resolve) => {
              const modal = new ConflictResolutionModal(
                this.app,
                this,
                page.name,
                body,
                remoteContent,
                localModified,
                remoteUpdated,
                async (choice) => {
                  try {
                    if (choice === "local") {
                      if (!(existingFile instanceof import_obsidian.TFile)) {
                        throw new Error("Expected existing local file during conflict resolution.");
                      }
                      const cleanedBody = this.stripLeadingTitleFromBody(body, page.name);
                      await this.pushPage(page.id, cleanedBody, page.name);
                      await this.updateLocalSyncTime(existingFile, frontmatter, body);
                      new import_obsidian.Notice(`\u2705 Pushed local version of: ${page.name}`);
                      resolve("pushed");
                    } else if (choice === "remote") {
                      await this.pullPage(page, expectedFilePath, book, chapter);
                      new import_obsidian.Notice(`\u2705 Pulled remote version of: ${page.name}`);
                      resolve("pulled");
                    } else {
                      new import_obsidian.Notice(`\u23ED\uFE0F Skipped conflict: ${page.name}`);
                      resolve("skipped");
                    }
                  } catch (error) {
                    console.error(`Error resolving conflict for ${page.name}:`, error);
                    new import_obsidian.Notice(`\u274C Error resolving conflict: ${page.name}`);
                    resolve("error");
                  }
                }
              );
              modal.open();
            });
          } else {
            if (!(existingFile instanceof import_obsidian.TFile)) {
              throw new Error("Expected existing local file while pushing newer local version.");
            }
            const cleanedBody = this.stripLeadingTitleFromBody(body, page.name);
            await this.pushPage(page.id, cleanedBody, page.name);
            await this.updateLocalSyncTime(existingFile, frontmatter, body);
            return "pushed";
          }
        } else {
          if (!lastSynced || remoteUpdated > lastSynced) {
            await this.pullPage(page, expectedFilePath, book, chapter);
            return "pulled";
          } else {
            return "skipped";
          }
        }
      } else {
        await this.pullPage(page, expectedFilePath, book, chapter);
        return "pulled";
      }
    } catch (error) {
      console.error(`Failed to sync page ${pageId}:`, error);
      return "error";
    }
  }
  async pullPage(page, filePath, book, chapter) {
    var _a;
    let content = "";
    try {
      content = await this.exportPageMarkdown(page.id);
    } catch (error) {
      console.log(`Markdown export failed for page ${page.id}, converting HTML`);
      content = this.htmlToMarkdown(page.html);
    }
    content = this.stripLeadingTitleFromBody(content, page.name);
    const metadata = {
      title: page.name,
      bookstack_id: page.id,
      book_id: book.id,
      chapter_id: (_a = chapter == null ? void 0 : chapter.id) != null ? _a : null,
      book_name: book.name,
      book_description: book.description,
      created: page.created_at,
      updated: page.updated_at,
      last_synced: new Date().toISOString()
    };
    if (chapter) {
      metadata.chapter_name = chapter.name;
      metadata.chapter_description = chapter.description;
    }
    const fullContent = this.createFrontmatter(metadata) + content;
    await this.createOrUpdateFile(filePath, fullContent);
  }
  async getRemotePageContent(page) {
    try {
      return await this.exportPageMarkdown(page.id);
    } catch (error) {
      console.log(`Markdown export failed for page ${page.id}, converting HTML`);
      return this.htmlToMarkdown(page.html);
    }
  }
  async pushPage(pageId, content, name) {
    await this.updatePage(pageId, content, name);
  }
  async updateLocalSyncTime(file, frontmatter, body) {
    frontmatter.last_synced = new Date().toISOString();
    const fullContent = this.createFrontmatter(frontmatter) + body;
    await this.app.vault.modify(file, fullContent);
  }
  async ensureFolderExists(path) {
    const folders = path.split("/");
    let currentPath = "";
    for (const folder of folders) {
      currentPath = currentPath ? `${currentPath}/${folder}` : folder;
      const folderExists = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folderExists) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  async createOrUpdateFile(path, content) {
    const existingFile = this.app.vault.getAbstractFileByPath(path);
    if (existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(path, content);
    }
  }
  sanitizeFileName(name) {
    return name.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim();
  }
  async findFileByBookStackId(pageId, parentPath) {
    var _a;
    if (this.pageFolderCache.has(pageId)) {
      const cachedFile = this.pageFolderCache.get(pageId);
      if (((_a = cachedFile.parent) == null ? void 0 : _a.path) === parentPath) {
        return cachedFile;
      }
      this.pageFolderCache.delete(pageId);
    }
    const folder = this.app.vault.getAbstractFileByPath(parentPath);
    if (!(folder instanceof import_obsidian.TFolder)) {
      return null;
    }
    for (const file of folder.children) {
      if (!(file instanceof import_obsidian.TFile) || file.extension !== "md")
        continue;
      try {
        const frontmatter = await this.extractFrontmatterOnly(file);
        if (frontmatter.bookstack_id === pageId) {
          this.pageFolderCache.set(pageId, file);
          return file;
        }
      } catch (error) {
        console.error(`Error reading file ${file.path}:`, error);
      }
    }
    return null;
  }
  async findBookFolderByBookId(bookId, basePath) {
    if (this.bookFolderCache.has(bookId)) {
      return this.bookFolderCache.get(bookId);
    }
    const baseFolder = this.app.vault.getAbstractFileByPath(basePath);
    if (!(baseFolder instanceof import_obsidian.TFolder))
      return null;
    for (const item of baseFolder.children) {
      if (!(item instanceof import_obsidian.TFolder))
        continue;
      const hasMatchingPage = await this.folderContainsBookId(item, bookId);
      if (hasMatchingPage) {
        this.bookFolderCache.set(bookId, item.path);
        return item.path;
      }
    }
    return null;
  }
  async folderContainsBookId(folder, bookId) {
    for (const file of folder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        try {
          const frontmatter = await this.extractFrontmatterOnly(file);
          if (frontmatter.book_id === bookId) {
            return true;
          }
        } catch (error) {
        }
      }
      if (file instanceof import_obsidian.TFolder) {
        const found = await this.folderContainsBookId(file, bookId);
        if (found)
          return true;
      }
    }
    return false;
  }
  async findChapterFolderByChapterId(chapterId, bookPath) {
    if (this.chapterFolderCache.has(chapterId)) {
      return this.chapterFolderCache.get(chapterId);
    }
    const bookFolder = this.app.vault.getAbstractFileByPath(bookPath);
    if (!(bookFolder instanceof import_obsidian.TFolder))
      return null;
    for (const item of bookFolder.children) {
      if (!(item instanceof import_obsidian.TFolder))
        continue;
      const hasMatchingPage = await this.folderContainsChapterId(item, chapterId);
      if (hasMatchingPage) {
        this.chapterFolderCache.set(chapterId, item.path);
        return item.path;
      }
    }
    return null;
  }
  async folderContainsChapterId(folder, chapterId) {
    for (const file of folder.children) {
      if (file instanceof import_obsidian.TFile && file.extension === "md") {
        try {
          const frontmatter = await this.extractFrontmatterOnly(file);
          if (frontmatter.chapter_id === chapterId) {
            return true;
          }
        } catch (error) {
        }
      }
    }
    return false;
  }
  async findOrCreateFolderWithRename(folderId, expectedName, parentPath, finderFn, folderType) {
    if (folderType === "book") {
      this.bookFolderCache.delete(folderId);
    } else if (folderType === "chapter") {
      this.chapterFolderCache.delete(folderId);
    }
    let existingPath = await finderFn(folderId, parentPath);
    const sanitizedName = this.sanitizeFileName(expectedName);
    const expectedPath = `${parentPath}/${sanitizedName}`;
    if (existingPath) {
      const existingFolder = this.app.vault.getAbstractFileByPath(existingPath);
      if (existingFolder instanceof import_obsidian.TFolder) {
        const currentName = existingFolder.name;
        const expectedNameSanitized = sanitizedName;
        if (currentName !== expectedNameSanitized) {
          console.log(`[BookStack] Detected renamed ${folderType}: "${currentName}" should be "${expectedNameSanitized}"`);
          console.log(`[BookStack] Renaming ${folderType} folder: ${existingPath} \u2192 ${expectedPath}`);
          try {
            await this.app.fileManager.renameFile(existingFolder, expectedNameSanitized);
            console.log(`[BookStack] Successfully renamed ${folderType} folder to match BookStack`);
          } catch (error) {
            console.error(`[BookStack] Failed to rename ${folderType} folder:`, error);
          }
        }
      }
    }
    const finalPath = existingPath || expectedPath;
    if (!existingPath) {
      await this.ensureFolderExists(finalPath);
      console.log(`[BookStack] Created new ${folderType} folder: ${finalPath}`);
    }
    if (folderType === "book") {
      this.bookFolderCache.set(folderId, finalPath);
    } else if (folderType === "chapter") {
      this.chapterFolderCache.set(folderId, finalPath);
    }
    return finalPath;
  }
  async renameFileIfNeeded(file, expectedName, parentPath) {
    const expectedFileName = `${this.sanitizeFileName(expectedName)}.md`;
    const expectedFilePath = `${parentPath}/${expectedFileName}`;
    if (file.name !== expectedFileName) {
      console.log(`[BookStack] Renaming file: ${file.name} \u2192 ${expectedFileName}`);
      await this.app.fileManager.renameFile(file, expectedFilePath);
      return this.app.vault.getAbstractFileByPath(expectedFilePath);
    }
    return file;
  }
  shouldSkipFile(file) {
    if (file.extension !== this.MARKDOWN_EXTENSION)
      return true;
    if (file.name === this.README_FILENAME)
      return true;
    return false;
  }
  handleSyncError(context, error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    console.error(`[BookStack] ${context}:`, error);
  }
  isTFile(file) {
    return file instanceof import_obsidian.TFile;
  }
  async testConnection() {
    new import_obsidian.Notice("Testing BookStack connection...");
    if (!this.settings.baseUrl) {
      new import_obsidian.Notice("\u274C BookStack URL is not configured");
      return;
    }
    let tokenId;
    let tokenSecret;
    try {
      ({ tokenId, tokenSecret } = await this.getCredentials());
    } catch (err) {
      console.error("[BookStack] SecretStorage error", err);
      new import_obsidian.Notice("\u274C Failed to read secrets from Obsidian SecretStorage");
      return;
    }
    if (!tokenId || !tokenSecret) {
      new import_obsidian.Notice("\u274C API credentials are missing or inaccessible");
      return;
    }
    console.log("[BookStack] Test connection environment", {
      baseUrl: this.settings.baseUrl,
      isMobile: this.isMobile,
      hasTokenId: !!tokenId,
      hasTokenSecret: !!tokenSecret
    });
    try {
      const start = performance.now();
      const response = await this.makeRequest("books");
      const duration = Math.round(performance.now() - start);
      if (!response || !Array.isArray(response.data)) {
        console.error("[BookStack] Unexpected API response", response);
        new import_obsidian.Notice("\u26A0\uFE0F Connected, but received an unexpected API response");
        return;
      }
      new import_obsidian.Notice(
        `\u2705 Connection successful
Books visible: ${response.data.length}
Platform: ${this.isMobile ? "Mobile" : "Desktop"}
Latency: ${duration} ms`
      );
      console.log("[BookStack] Connection test successful", {
        bookCount: response.data.length,
        latencyMs: duration
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      console.error("[BookStack] Connection test failed", {
        error,
        isMobile: this.isMobile,
        baseUrl: this.settings.baseUrl
      });
      let hint = "";
      if (message.includes("Failed to fetch")) {
        hint = "Network request failed.\n\u2022 Check HTTPS certificate\n\u2022 Check CORS settings\n\u2022 Mobile apps require public HTTPS endpoints";
      } else if (message.includes("401") || message.includes("403")) {
        hint = "Authentication failed.\n\u2022 Verify API token permissions\n\u2022 Ensure token belongs to a non-disabled user";
      }
      new import_obsidian.Notice(`\u274C Connection failed

${message}${hint ? `

${hint}` : ""}

See console for details`);
    }
  }
};
var BookSelectionModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.books = [];
    this.plugin = plugin;
    this.selectedBooks = new Set(plugin.settings.selectedBooks);
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Books to Sync" });
    const loadingEl = contentEl.createEl("p", { text: "Loading books..." });
    try {
      this.books = await this.plugin.listBooks();
      loadingEl.remove();
      if (this.books.length === 0) {
        contentEl.createEl("p", { text: "No books found in your BookStack instance." });
        return;
      }
      const listEl = contentEl.createEl("div", { cls: "book-list" });
      for (const book of this.books) {
        const itemEl = listEl.createEl("div", { cls: "book-item" });
        const checkbox = itemEl.createEl("input", { type: "checkbox" });
        checkbox.checked = this.selectedBooks.has(book.id);
        checkbox.addEventListener("change", () => {
          if (checkbox.checked)
            this.selectedBooks.add(book.id);
          else
            this.selectedBooks.delete(book.id);
        });
        itemEl.createEl("label", { text: book.name });
      }
      const buttonContainer = contentEl.createEl("div", { cls: "button-container" });
      const saveBtn = buttonContainer.createEl("button", { text: "Save Selection" });
      saveBtn.addEventListener("click", async () => {
        this.plugin.settings.selectedBooks = Array.from(this.selectedBooks);
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`${this.selectedBooks.size} books selected for sync`);
        this.close();
      });
    } catch (error) {
      loadingEl.setText(`Error loading books: ${error.message}`);
      console.error("Error loading books:", error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConflictResolutionModal = class extends import_obsidian.Modal {
  constructor(app, plugin, pageName, localContent, remoteContent, localModified, remoteModified, onResolve) {
    super(app);
    this.plugin = plugin;
    this.pageName = pageName;
    this.localContent = localContent;
    this.remoteContent = remoteContent;
    this.localModified = localModified;
    this.remoteModified = remoteModified;
    this.onResolve = onResolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("bookstack-conflict-modal");
    contentEl.createEl("h2", { text: "\u26A0\uFE0F Sync Conflict Detected" });
    contentEl.createEl("p", {
      text: `The page "${this.pageName}" has been modified in both Obsidian and BookStack.`,
      cls: "conflict-description"
    });
    const timingEl = contentEl.createEl("div", { cls: "conflict-timing" });
    timingEl.createEl("p", { text: `Local modified: ${this.localModified.toLocaleString()}` });
    timingEl.createEl("p", { text: `Remote modified: ${this.remoteModified.toLocaleString()}` });
    const previewContainer = contentEl.createEl("div", { cls: "conflict-preview-container" });
    const localPreview = previewContainer.createEl("div", { cls: "conflict-preview" });
    localPreview.createEl("h3", { text: "\u{1F4DD} Local Version (Obsidian)" });
    const localPre = localPreview.createEl("pre", { cls: "conflict-content" });
    localPre.textContent = this.truncateContent(this.localContent);
    const remotePreview = previewContainer.createEl("div", { cls: "conflict-preview" });
    remotePreview.createEl("h3", { text: "\u2601\uFE0F Remote Version (BookStack)" });
    const remotePre = remotePreview.createEl("pre", { cls: "conflict-content" });
    remotePre.textContent = this.truncateContent(this.remoteContent);
    const buttonContainer = contentEl.createEl("div", { cls: "conflict-buttons" });
    const keepLocalBtn = buttonContainer.createEl("button", {
      text: "\u2B06\uFE0F Keep Local (Push to BookStack)",
      cls: "mod-cta"
    });
    keepLocalBtn.addEventListener("click", () => {
      this.onResolve("local");
      this.close();
    });
    const keepRemoteBtn = buttonContainer.createEl("button", {
      text: "\u2B07\uFE0F Keep Remote (Pull from BookStack)",
      cls: "mod-warning"
    });
    keepRemoteBtn.addEventListener("click", () => {
      this.onResolve("remote");
      this.close();
    });
    const skipBtn = buttonContainer.createEl("button", {
      text: "\u23ED\uFE0F Skip for Now"
    });
    skipBtn.addEventListener("click", () => {
      this.onResolve("skip");
      this.close();
    });
  }
  truncateContent(content, maxLength = 500) {
    if (content.length <= maxLength)
      return content;
    return content.substring(0, maxLength) + "\n\n... (content truncated)";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var BookStackSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "BookStack Sync Settings" });
    new import_obsidian.Setting(containerEl).setName("BookStack URL").setDesc("Base URL of your BookStack instance (e.g., https://bookstack.example.com)").addText(
      (text) => text.setPlaceholder("https://bookstack.example.com").setValue(this.plugin.settings.baseUrl).onChange(async (value) => {
        this.plugin.settings.baseUrl = value.replace(/\/$/, "");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Token ID").setDesc("Select or create a secret for your BookStack API token ID").addComponent(
      (el) => new import_obsidian.SecretComponent(this.app, el).setValue(this.plugin.settings.tokenIdSecret).onChange(async (value) => {
        this.plugin.settings.tokenIdSecret = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("API Token Secret").setDesc("Select or create a secret for your BookStack API token secret").addComponent(
      (el) => new import_obsidian.SecretComponent(this.app, el).setValue(this.plugin.settings.tokenSecretSecret).onChange(async (value) => {
        this.plugin.settings.tokenSecretSecret = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Folder").setDesc("Folder where BookStack content will be synced").addText(
      (text) => text.setPlaceholder("BookStack").setValue(this.plugin.settings.syncFolder).onChange(async (value) => {
        this.plugin.settings.syncFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Mode").setDesc("Choose how sync operates: pull from BookStack, push to BookStack, or bidirectional").addDropdown(
      (dropdown) => dropdown.addOption("bidirectional", "Bidirectional (Smart sync based on timestamps)").addOption("pull-only", "Pull Only (BookStack \u2192 Obsidian)").addOption("push-only", "Push Only (Obsidian \u2192 BookStack)").setValue(this.plugin.settings.syncMode).onChange(async (value) => {
        this.plugin.settings.syncMode = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync books at regular intervals").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
        this.plugin.settings.autoSync = value;
        await this.plugin.saveSettings();
        if (value)
          this.plugin.startAutoSync();
        else
          this.plugin.stopAutoSync();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Sync Interval (minutes)").setDesc("How often to sync when auto-sync is enabled").addText(
      (text) => text.setPlaceholder("60").setValue(String(this.plugin.settings.syncInterval)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          this.plugin.settings.syncInterval = num;
          await this.plugin.saveSettings();
          if (this.plugin.settings.autoSync)
            this.plugin.startAutoSync();
        }
      })
    );
    containerEl.createEl("h3", { text: "How to get API credentials" });
    containerEl.createEl("p", { text: "1. Log into your BookStack instance" });
    containerEl.createEl("p", { text: "2. Go to your profile settings" });
    containerEl.createEl("p", { text: '3. Scroll to "API Tokens" section' });
    containerEl.createEl("p", { text: "4. Create a new token and copy the ID and Secret" });
    containerEl.createEl("p", { text: "5. Use the dropdowns above to create new secrets or select existing ones" });
    containerEl.createEl("h3", { text: "About Sync Modes" });
    containerEl.createEl("p", { text: "Bidirectional: Compares timestamps and syncs in the direction of the most recent change. If both changed, local is preserved. Creates new pages in BookStack when you add .md files locally." });
    containerEl.createEl("p", { text: "Pull Only: Only downloads changes from BookStack, never uploads local changes or creates new pages." });
    containerEl.createEl("p", { text: "Push Only: Only uploads local changes to BookStack and creates new pages from local .md files, never downloads remote changes." });
    containerEl.createEl("h3", { text: "Creating New Pages" });
    containerEl.createEl("p", { text: "To create a new page in BookStack: Simply create a new .md file in a book or chapter folder. During the next sync, the plugin will automatically create the page in BookStack and add the bookstack_id to the frontmatter." });
    containerEl.createEl("h3", { text: "Creating New Chapters" });
    containerEl.createEl("p", { text: "To create a new chapter in BookStack: Simply create a new folder in a book. During the next sync, the plugin will automatically create the chapter in BookStack and add the bookstack_id to the frontmatter." });
    containerEl.createEl("h3", { text: "About SecretStorage" });
    containerEl.createEl("p", { text: "This plugin uses Obsidian's SecretStorage to securely store your API credentials. Secrets are stored separately from plugin settings and can be shared across multiple plugins. You can manage all your secrets in Settings \u2192 About \u2192 Manage secrets." });
  }
};
